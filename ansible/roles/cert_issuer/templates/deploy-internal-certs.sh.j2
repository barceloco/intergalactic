#!/bin/bash
# Deploy certificates to internal services
# This script is called by lego as a renew hook after successful certificate renewal

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="{{ cert_issuer_config_dir }}"
COMPOSE_FILE="{{ cert_issuer_data_dir }}/docker-compose.yml"
LEGO_DATA_DIR="{{ cert_issuer_data_dir }}/data"  # Host directory for lego state
TEMP_EXTRACT_DIR=$(mktemp -d)  # Temporary directory to extract certs
DEPLOY_TARGETS="${CONFIG_DIR}/deploy-targets.json"
CERT_NAME="{{ cert_issuer_domain }}"

# Cleanup function
cleanup() {
    rm -rf "${TEMP_EXTRACT_DIR}"
}
trap cleanup EXIT

# This script must run on the host (not in container) to restart Docker containers
# If called from lego renew hook, it will fail - that's expected.
# The renewal script on the host will call this script manually after renewal.

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1" >&2
    logger -t lego-deploy "INFO: $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
    logger -t lego-deploy "WARN: $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    logger -t lego-deploy "ERROR: $1"
}

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    log_error "This script must be run as root"
    exit 1
fi

# Extract certificates from lego data directory
log_info "Extracting certificates from: ${LEGO_DATA_DIR}"

# Copy certificates directly from host directory
if [[ -f "${LEGO_DATA_DIR}/certificates/_.${CERT_NAME}.crt" ]]; then
    CERT_FILE="${LEGO_DATA_DIR}/certificates/_.${CERT_NAME}.crt"
    KEY_FILE="${LEGO_DATA_DIR}/certificates/_.${CERT_NAME}.key"
elif [[ -f "${LEGO_DATA_DIR}/certificates/${CERT_NAME}.crt" ]]; then
    CERT_FILE="${LEGO_DATA_DIR}/certificates/${CERT_NAME}.crt"
    KEY_FILE="${LEGO_DATA_DIR}/certificates/${CERT_NAME}.key"
else
    log_error "Certificate file not found in ${LEGO_DATA_DIR}/certificates/"
    log_error "Expected: _.${CERT_NAME}.crt or ${CERT_NAME}.crt"
    exit 1
fi

# Copy to temp directory for processing
cp "${CERT_FILE}" "${TEMP_EXTRACT_DIR}/cert.crt"
cp "${KEY_FILE}" "${TEMP_EXTRACT_DIR}/key.key"

# Determine certificate file names (now in temp directory)
CERT_FILE="${TEMP_EXTRACT_DIR}/cert.crt"
KEY_FILE="${TEMP_EXTRACT_DIR}/key.key"

if [[ ! -f "${CERT_FILE}" ]] || [[ ! -f "${KEY_FILE}" ]]; then
    log_error "Certificate files not found after extraction"
    log_error "Expected: ${CERT_FILE} and ${KEY_FILE}"
    exit 1
fi

log_info "Found certificate: ${CERT_FILE}"
log_info "Found private key: ${KEY_FILE}"

# Verify certificate and key files exist and are readable
if [[ ! -r "${CERT_FILE}" ]] || [[ ! -r "${KEY_FILE}" ]]; then
    log_error "Certificate or key file is not readable"
    exit 1
fi

# Verify certificate is valid (basic check)
if ! openssl x509 -in "${CERT_FILE}" -noout -text &> /dev/null; then
    log_error "Certificate file appears to be invalid"
    exit 1
fi

log_info "Certificate validation passed"

# Read deploy targets
if [[ ! -f "${DEPLOY_TARGETS}" ]]; then
    log_error "Deploy targets file not found: ${DEPLOY_TARGETS}"
    exit 1
fi

# Parse deploy targets (simple JSON parsing - assumes valid JSON)
TARGETS=$(python3 -c "
import json
import sys
try:
    with open('${DEPLOY_TARGETS}', 'r') as f:
        data = json.load(f)
        targets = data.get('targets', [])
        for target in targets:
            print(f\"{target['host']}|{target['method']}|{target['dest_dir']}|{target['owner']}|{target['group']}|{target['mode_cert']}|{target['mode_key']}|{target['reload']}\")
except Exception as e:
    print(f'ERROR: {e}', file=sys.stderr)
    sys.exit(1)
")

if [[ -z "${TARGETS}" ]]; then
    log_error "No deployment targets found in ${DEPLOY_TARGETS}"
    exit 1
fi

# Deploy to each target
while IFS='|' read -r host method dest_dir owner group mode_cert mode_key reload_cmd; do
    log_info "Deploying to ${host} (method: ${method})"
    
    if [[ "${method}" == "local_copy" ]]; then
        # Local file copy (same host)
        DEST_CERT="${dest_dir}/${CERT_NAME}.crt"
        DEST_KEY="${dest_dir}/${CERT_NAME}.key"
        DEST_CERT_TMP="${DEST_CERT}.tmp"
        DEST_KEY_TMP="${DEST_KEY}.tmp"
        
        # Create backup of existing certs
        if [[ -f "${DEST_CERT}" ]]; then
            BACKUP_DIR="${dest_dir}/backup"
            mkdir -p "${BACKUP_DIR}"
            BACKUP_SUFFIX=$(date +%Y%m%d_%H%M%S)
            cp "${DEST_CERT}" "${BACKUP_DIR}/${CERT_NAME}.crt.${BACKUP_SUFFIX}"
            cp "${DEST_KEY}" "${BACKUP_DIR}/${CERT_NAME}.key.${BACKUP_SUFFIX}"
            log_info "Backed up existing certificates to ${BACKUP_DIR}/"
        fi
        
        # Copy to temporary files
        cp "${CERT_FILE}" "${DEST_CERT_TMP}"
        cp "${KEY_FILE}" "${DEST_KEY_TMP}"
        
        # Set permissions on temp files
        chmod "${mode_cert}" "${DEST_CERT_TMP}"
        chmod "${mode_key}" "${DEST_KEY_TMP}"
        chown "${owner}:${group}" "${DEST_CERT_TMP}" "${DEST_KEY_TMP}"
        
        # Verify temp files are valid
        if ! openssl x509 -in "${DEST_CERT_TMP}" -noout -text &> /dev/null; then
            log_error "Copied certificate file is invalid, aborting"
            rm -f "${DEST_CERT_TMP}" "${DEST_KEY_TMP}"
            exit 1
        fi
        
        # Atomically move into place
        mv "${DEST_CERT_TMP}" "${DEST_CERT}"
        mv "${DEST_KEY_TMP}" "${DEST_KEY}"
        
        log_info "✓ Certificates deployed to ${dest_dir}"
        
        # Reload service
        log_info "Reloading service: ${reload_cmd}"
        if eval "${reload_cmd}"; then
            log_info "✓ Service reloaded successfully"
            
            # Verify service is running
            sleep 2
            if docker ps --format "{{ '{{' }}.Names{{ '}}' }}" | grep -q "^{{ edge_ingress_container_name }}$"; then
                log_info "✓ Service is running after reload"
            else
                log_warn "Service may not be running, check manually"
            fi
        else
            log_error "Service reload failed!"
            
            # Restore backup if available
            if [[ -n "${BACKUP_SUFFIX:-}" ]] && [[ -f "${BACKUP_DIR}/${CERT_NAME}.crt.${BACKUP_SUFFIX}" ]]; then
                log_warn "Restoring backup certificates..."
                cp "${BACKUP_DIR}/${CERT_NAME}.crt.${BACKUP_SUFFIX}" "${DEST_CERT}"
                cp "${BACKUP_DIR}/${CERT_NAME}.key.${BACKUP_SUFFIX}" "${DEST_KEY}"
                eval "${reload_cmd}" || true
                log_warn "Backup restored, but service may need manual intervention"
            fi
            
            exit 1
        fi
        
    else
        log_error "Unsupported deployment method: ${method}"
        exit 1
    fi
    
done <<< "${TARGETS}"

log_info "Certificate deployment completed successfully!"
exit 0
